# What is Authentication?
The process of verifying the identity of a user or client.

3 Main Types:
1. Something you **know**
2. Something you **have**
3. Something you **are** or do

|Knowledge|Ownership|Inherence|
|---|---|---|
|Password|ID card|Fingerprint|
|PIN|Security Token|Facial Pattern|
|Answer to Security Question|Authenticator App|Voice Recognition|

## Authentication vs Authorization
**Authentication:** The process of verifying that a user is who they claim to be. 
**Authorization:** Verifying whether a user is allowed to do something.
### Authentication Vulnerabilities Arising
Most vulnerabilities in authentication mechanisms occur in one of two ways:
1. The authentication mechanisms are weak because they fail to adequately protect against brute-force attacks.
2. Logic flaws or poor coding in the implementation allow the authentication mechanisms to be bypassed entirely by an attacker. 
	- Sometimes called "broken authentication"

Logic flaws cause the website to behave unexpectedly, which may or may not be a security issue. However, as authentication is so critical to security, it's very likely that flawed authentication logic exposes the website to security issues.

The most widespread authentication method in web applications is `login forms`.
# Authentication Attacks
## Brute-Force Login Attacks
### Enumerating Users
User enumeration vulnerabilities arise when a web application responds differently to registered/valid and invalid inputs for authentication endpoints.

To obtain a list of valid users, an attacker typically requires a wordlist of usernames to test.
- A good starting point is the wordlist collection [SecLists](https://github.com/danielmiessler/SecLists/tree/master/Usernames).
- Or refer to [[Wordlists]]
	- Can use [[Using Hydra]] after obtaining a wordlist to enumerate
	- Can also use [[/Offensive Security Techniques/Tools & Commands/FFUF/FFUF]]
#### Example
Let us exploit this difference in error messages returned and use SecLists's wordlist `xato-net-10-million-usernames.txt` to enumerate valid users with `ffuf`.

```bash
ffuf -w /opt/useful/seclists/Usernames/xato-net-10-million-usernames.txt -u http://172.17.0.2/index.php -X POST -H "Content-Type: application/x-www-form-urlencoded" -d "username=FUZZ&password=invalid" -fr "Unknown user"
```
- Specify the wordlist with the `-w` parameter
- Specify the POST data with the `-d` parameter
- Add the keyword `FUZZ` in the username to fuzz valid users
- Filter out invalid users by removing responses containing the string `Unknown user`
### Brute-Forcing Passwords
To start brute-forcing passwords, we need a user or a list of users to target. Using the techniques covered in the previous section, we determine that admin is a username for a valid user, therefore, we will attempt brute-forcing its password.

We can get password lists by creating them from [[Wordlists]], or using a popular one list `rockyou.txt`.
- After obtaining a wordlist, make sure to `grep` to match the password policies and output into a separate file

Once again, we can use [[/Offensive Security Techniques/Tools & Commands/FFUF/FFUF]] to bruteforce the password
## Brute-Forcing Password Reset Tokens
### Identifying Weak Reset Tokens
Reset tokens (in the form of a code or temporary password) are secret data generated by an application when a user requests a password reset. The user can then change their password by presenting the reset token.

We can create an account, then ask for a password reset and get an email to reset our password to find the token. Once we find the token, we can use this to brute force password reset tokens for other users with the information of how many digits and what the token contains.
### Attacking Weak Reset Tokens
We will use `ffuf` to brute-force all possible reset tokens. First, we need to create a wordlist of all possible tokens from `0000` to `9999`, which we can achieve with `seq`:
```bash
seq -w 0 9999 > tokens.txt
```
- The `-w` flag pads all numbers to the same length by prepending zeroes,

We can try to brute-force all active reset tokens. If we want to target a specific user, we should send a password reset request for that user first to create a reset token. We can then specify the wordlist in `ffuf` to brute-force all active reset-tokens:
```bash
ffuf -w ./tokens.txt -u http://weak_reset.htb/reset_password.php?token=FUZZ -fr "The provided token is invalid"
```

By specifying the reset token in the GET-parameter `token` in the `/reset_password.php` endpoint (which we can find by creating our own account and going through our own password reset steps), we can reset the password of the corresponding account, enabling us to take over the account.
## Brute-Forcing 2FA Codes
### Attacking Two-Factor Authentication (2FA)
TOTPs typically consist only of digits, making them potentially guessable if the length is insufficient and the web application does not implement measures against successive submission of incorrect OTPs.

First we need to obtain valid credentials. Next we need to find out what the OTP consists of (how many numbers, does it contain letters, etc.).

Once we find out what the OTP consists of, we can create a txt file with all possible combinations using `seq` again:
```bash
seq -w 0 9999 > tokens.txt
```

Then we can attempt to login with FFUF:
```bash
ffuf -w ./tokens.txt -u http://bf_2fa.htb/2fa.php -X POST -H "Content-Type: application/x-www-form-urlencoded" -b "PHPSESSID=0sm6tj93knc494ulmtaiglc6n9" -d "otp=FUZZ" -fr "Invalid 2FA Code" -t 60
```
- We can find the site that requests for 2fa from authenticating with our own account and observing from the process
- Dont forget to change `otp` to the name in the request you are sending, as well as the error message `-fr`
### Other Options
If you are able to login with valid credentials, once you get to the page asking for your OTP, try intercepting the request for this page in Burp, sending to repeater, changing the request to a `GET` request and change the destination to the users profile (e.g. `profile.php` or the admin interface `admin.php`)
# Weak Brute-Force Protection
## Rate Limits
Rate limiting is a crucial technique employed in software development and network management to control the rate of incoming requests to a system or API. Its primary purpose is to prevent servers from being overwhelmed by too many requests at once, prevent system downtime, and prevent brute-force attacks by limiting the number of requests allowed within a specified time frame

A rate limit should only be enforced on an attacker, not regular users, to prevent DoS scenarios.

This enables an attacker to conduct a brute-force attack by randomizing the `X-Forwarded-For` header in each HTTP request to avoid the rate limit.
## CAPTCHAs
A security measure to prevent bots from submitting requests.

From a security perspective, it is essential not to reveal a CAPTCHA's solution in the response, as we can see in the following flawed CAPTCHA implementation:
![](https://academy.hackthebox.com/storage/modules/269/bf/captcha_1.png)

Additionally, tools and browser extensions to solve CAPTCHAs automatically are rising.

Many open-source CAPTCHA solvers can be found.